<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Crossword Composer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              mono: ["IBM Plex Mono", "ui-monospace", "SFMono-Regular", "Menlo", "Monaco", "Consolas", "Liberation Mono", "Courier New", "monospace"],
            },
          },
        },
      };
    </script>
  </head>
  <body class="min-h-screen bg-zinc-950 text-zinc-100 font-mono">
    <div id="app" class="mx-auto flex min-h-screen max-w-6xl flex-col gap-10 px-6 py-12">
      <header class="flex flex-col gap-4">
        <h1 class="text-3xl tracking-tight">Crossword Composer</h1>
        <p class="max-w-2xl text-sm text-zinc-400">Design a crossword grid, pick curated word banks, and solve it instantly in the browser with the MiniZinc WebAssembly runtime.</p>
      </header>
      <main class="flex flex-col gap-10">
        <section class="flex flex-col gap-6 rounded border border-zinc-800 bg-zinc-900/30 p-6 backdrop-blur">
          <div class="grid gap-6 md:grid-cols-2">
            <div class="flex flex-col gap-4">
              <div class="flex items-center justify-between gap-4">
                <label class="text-sm uppercase tracking-[0.2em] text-zinc-500">Grid Size</label>
                <div class="flex items-center gap-3 text-sm text-zinc-300">
                  <div class="flex items-center gap-2">
                    <span>Rows</span>
                    <input v-model.number="rows" type="number" min="3" max="18" class="w-16 bg-zinc-900 px-2 py-1 text-right text-sm text-zinc-100 outline-none ring-1 ring-inset ring-zinc-700 transition focus:ring-zinc-400" />
                  </div>
                  <div class="flex items-center gap-2">
                    <span>Cols</span>
                    <input v-model.number="cols" type="number" min="3" max="18" class="w-16 bg-zinc-900 px-2 py-1 text-right text-sm text-zinc-100 outline-none ring-1 ring-inset ring-zinc-700 transition focus:ring-zinc-400" />
                  </div>
                </div>
              </div>
              <button @click="resetGrid" class="w-full rounded border border-zinc-700 bg-zinc-950 px-3 py-2 text-sm uppercase tracking-[0.2em] text-zinc-200 transition hover:border-zinc-400 hover:text-white">Clear Grid</button>
              <div class="rounded border border-zinc-800 bg-zinc-950/70 p-3 text-xs text-zinc-400">
                <div class="flex justify-between">
                  <span>Active cells</span>
                  <span>{{ openCellCount }}</span>
                </div>
                <div class="flex justify-between">
                  <span>Black cells</span>
                  <span>{{ blockedCellCount }}</span>
                </div>
                <div class="flex justify-between">
                  <span>Word slots</span>
                  <span>{{ slotSummary.total }}</span>
                </div>
              </div>
            </div>
            <div class="flex flex-col gap-3">
              <label class="text-sm uppercase tracking-[0.2em] text-zinc-500">Word Lengths</label>
              <div class="flex flex-wrap gap-2">
                <button v-for="option in lengthOptions" :key="option.length" @click="toggleLength(option.length)" :class="[
                    'rounded border px-3 py-2 text-xs uppercase tracking-[0.2em] transition',
                    option && option.selected ? 'border-zinc-200 bg-zinc-100 text-zinc-900' : 'border-zinc-700 bg-zinc-950 text-zinc-200 hover:border-zinc-400',
                  ]">
                  {{ option?.label || '' }}
                </button>
              </div>
              <div class="rounded border border-zinc-800 bg-zinc-950/70 p-3 text-xs text-zinc-400">
                <div class="flex justify-between">
                  <span>Selected words</span>
                  <span>{{ activeWordCount }}</span>
                </div>
                <div class="flex flex-wrap gap-2 pt-3">
                  <span v-for="option in lengthOptions" :key="`length-chip-${option.length}`" class="rounded-full border border-zinc-800 px-2 py-1 text-[0.65rem] uppercase tracking-[0.25em] text-zinc-500" v-if="option && option.selected">
                    {{ option.length }}&nbsp;({{ option.count }})
                  </span>
                </div>
              </div>
            </div>
          </div>
          <div class="grid gap-6 md:grid-cols-[minmax(0,_2fr)_minmax(0,_1fr)]">
            <div class="rounded border border-zinc-800 bg-zinc-950/70 p-4">
              <div class="flex items-center justify-between">
                <h2 class="text-sm uppercase tracking-[0.2em] text-zinc-500">Layout</h2>
                <span class="text-xs text-zinc-500">Click or drag to toggle blocks</span>
              </div>
              <div
                class="mt-4 grid gap-px border border-zinc-800 bg-zinc-900/40 p-2"
                :style="{ gridTemplateColumns: `repeat(${cols}, minmax(0, 1fr))` }"
                @pointerleave="endDrag"
              >
                <button
                  v-for="(cell, cellIndex) in flatGrid"
                  :key="cellIndex"
                  @pointerdown="startDrag(cellIndex)"
                  @pointerenter="dragCell(cellIndex)"
                  @pointerup="endDrag"
                  class="flex aspect-square items-center justify-center text-base font-semibold uppercase transition"
                  :class="cellClass(cellIndex)"
                >
                  <span class="select-none">{{ cellLabel(cellIndex) }}</span>
                </button>
              </div>
            </div>
            <div class="flex flex-col gap-4 rounded border border-zinc-800 bg-zinc-950/70 p-4">
              <h2 class="text-sm uppercase tracking-[0.2em] text-zinc-500">Solver</h2>
              <div class="space-y-2 text-sm text-zinc-300">
                <p v-if="!ready && !loadError">Preparing MiniZinc runtime…</p>
                <p v-if="loadError" class="text-red-400">{{ loadError }}</p>
                <p v-if="solveStatus">{{ solveStatus }}</p>
              </div>
              <button
                @click="solve"
                :disabled="disableSolve"
                class="w-full rounded border border-zinc-700 bg-zinc-950 px-3 py-2 text-sm uppercase tracking-[0.2em] transition disabled:cursor-not-allowed disabled:opacity-50 hover:border-zinc-300 hover:text-white"
              >
                {{ solving ? 'Solving…' : 'Solve Crossword' }}
              </button>
              <div v-if="solutionLetters.length" class="rounded border border-zinc-800 bg-zinc-900/40 p-3 text-xs text-zinc-300">
                <div class="flex justify-between">
                  <span>Status</span>
                  <span>{{ lastStatus }}</span>
                </div>
                <div class="flex justify-between">
                  <span>Filled slots</span>
                  <span>{{ solutionLetters.length }}</span>
                </div>
                <div class="flex flex-wrap gap-2 pt-3">
                  <span v-for="(entry, index) in solutionWords" :key="`solution-word-${index}`" class="rounded border border-zinc-800 px-2 py-1 text-[0.65rem] uppercase tracking-[0.25em] text-zinc-400">
                    {{ entry }}
                  </span>
                </div>
              </div>
            </div>
          </div>
        </section>
      </main>
    </div>
    <script type="module">
      import { createApp, ref, reactive, computed, watch, onMounted, onBeforeUnmount } from "https://unpkg.com/vue@3/dist/vue.esm-browser.js";
      import * as MiniZinc from "https://cdn.jsdelivr.net/npm/minizinc/dist/minizinc.mjs";

      const letters = "abcdefghijklmnopqrstuvwxyz";
      const createMatrix = (r, c) => Array.from({ length: r }, () => Array.from({ length: c }, () => "_"));
      const cloneMatrix = (matrix) => matrix.map((row) => row.slice());
      const buildProblemMatrix = (matrix) => {
        let id = 1;
        const mapped = matrix.map((row) => row.map((cell) => {
          if (cell === "#") return 0;
          const value = id;
          id += 1;
          return value;
        }));
        return { mapped, count: id - 1 };
      };
      const collectSegments = (grid, rows, cols) => {
        const segments = [];
        const extract = (sourceRows, sourceCols, mapper) => {
          for (let r = 0; r < sourceRows; r += 1) {
            const line = [];
            for (let c = 0; c < sourceCols; c += 1) {
              const value = mapper(r, c);
              if (value === 0) {
                if (line.length > 1) segments.push([...line]);
                line.length = 0;
              } else {
                line.push(value);
              }
            }
            if (line.length > 1) segments.push([...line]);
          }
        };
        extract(rows, cols, (r, c) => grid[r][c]);
        extract(cols, rows, (r, c) => grid[c][r]);
        return segments;
      };
      const gridPresentation = (matrix) => 
        matrix
            .map((row) => `%   ${row.map((cell) => (cell === "#" ? "#" : "_")).join(" ")}`).join("\n");
      const buildPuzzle = (matrix) => {
        const rows = matrix.length;
        const cols = matrix[0]?.length ?? 0;
        const { mapped, count } = buildProblemMatrix(matrix);
        const segments = collectSegments(mapped, rows, cols);
        const maxSegmentLength = segments.reduce((acc, segment) => Math.max(acc, segment.length), 1);
        const segmentLines = segments.map((segment) => {
          const padded = segment.concat(Array.from({ length: Math.max(maxSegmentLength - segment.length, 0) }, () => 0));
          return `${padded.join(", ")},`;
        });
        const problemLines = mapped.map((row) => `${row.join(", ")},`);
        const tables = segments.map((segment) => `table([${segment.map((value) => `L[${value}]`).join(", ")}], words${segment.length})`);
        const tableBlock = tables.length ? tables.join(" \n/\\ ") : "true";
        const content = [
          "%",
          "% Generated crossword",
          "%",
          `% (generated ${new Date().toISOString()} by browser grid)`,
          "%",
          "%",
          "% Problem to solve:",
          "%",
          gridPresentation(matrix),
          "",
          "include \"crosswords.mzn\";",
          "",
          "problem_name = \"crossword\";",
          "",
          `% number of letters to assign`,
          `N = ${count};`,
          "",
          "% distinct words",
          "require_distinct_words = 1;",
          "",
          "constraint",
          `  ${tableBlock}`,
          ";",
          "",
          "% The segments (words)",
          "% (0 for fill outs)",
          `int: max_length = ${maxSegmentLength};`,
          `int: num_segments = ${segments.length};`,
          "array[1..num_segments, 1..max_length] of int: segments = array2d(1..num_segments, 1..max_length,",
          "[",
          segmentLines.join("\n"),
          "]);",
          "",
          "",
          "% Problem where each cell is assigned a unique index.",
          "% (0 means blocked cell)",
          `int: rows = ${rows};`,
          `int: cols = ${cols};`,
          "array[1..rows, 1..cols] of int: problem = array2d(1..rows, 1..cols,",
          "[",
          problemLines.join("\n"),
          "]);",
          "",
        ].join("\n");
        return { content, metadata: { mapped, segments, rows, cols } };
      };
      const buildWordData = (wordsByLength) => {
        const lengths = Object.keys(wordsByLength)
          .map((value) => Number(value))
          .sort((a, b) => a - b);
        const blocks = lengths
          .filter((length) => wordsByLength[length]?.length)
          .map((length) => {
            const words = wordsByLength[length];
            const rows = words
              .map((word) => word.split("").map((letter) => letters.indexOf(letter) + 1))
              .map((codes) => `${codes.join(", ")},`).join("\n");
            return [
              `int: num_words${length} = ${words.length};`,
              `array[1..num_words${length}, 1..${length}] of int: words${length} = array2d(1..num_words${length}, 1..${length},`,
              "[",
              rows,
              "]);",
              "",
            ].join("\n");
          });
        return blocks.join("\n");
      };
      const deriveSlots = (matrix) => {
        const rows = matrix.length;
        const cols = matrix[0]?.length ?? 0;
        const { mapped } = buildProblemMatrix(matrix);
        const segments = collectSegments(mapped, rows, cols);
        const summary = segments.reduce((acc, segment) => {
          const len = segment.length;
          acc[len] = (acc[len] ?? 0) + 1;
          acc.total += 1;
          return acc;
        }, { total: 0 });
        return summary;
      };
      const app = createApp({
        setup() {
          const rows = ref(8);
          const cols = ref(8);
          const grid = ref(createMatrix(rows.value, cols.value));
          const dragging = reactive({ active: false, next: "#" });
          const ready = ref(false);
          const loadError = ref("");
          const solving = ref(false);
          const solveStatus = ref("");
          const lastStatus = ref("");
          const solutionLetters = ref([]);
          const solutionWords = ref([]);
          const wordSource = ref({});
          const availableLengths = ref([]);
          const selectedLengths = ref(new Set());
          const crosswordsModel = ref("");
          const slotSummary = computed(() => deriveSlots(grid.value || createMatrix(rows.value, cols.value)));
          const flatGrid = computed(() => (grid.value || []).flat());
          const openCellCount = computed(() => flatGrid.value.filter((cell) => cell !== "#").length);
          const blockedCellCount = computed(() => flatGrid.value.filter((cell) => cell === "#").length);
          const lengthOptions = computed(() =>
            (availableLengths.value ?? []).map((length) => ({
              length,
              selected: selectedLengths.value.has(length),
              count: wordSource.value[length]?.length ?? 0,
              label: `${length}L`,
            }))
          );
          const activeWordCount = computed(() => Array.from(selectedLengths.value || []).reduce((acc, length) => acc + (wordSource.value[length]?.length ?? 0), 0));
          const disableSolve = computed(() => !ready.value || solving.value || loadError.value.length > 0 || !slotSummary.value.total);
          const applyCell = (index, value) => {
            const next = cloneMatrix(grid.value);
            const r = Math.floor(index / cols.value);
            const c = index % cols.value;
            if (!next[r]) return;
            next[r][c] = value;
            grid.value = next;
          };
          const startDrag = (index) => {
            const current = flatGrid.value[index] ?? "_";
            const next = current === "#" ? "_" : "#";
            dragging.active = true;
            dragging.next = next;
            applyCell(index, next);
          };
          const dragCell = (index) => {
            if (!dragging.active) return;
            applyCell(index, dragging.next);
          };
          const endDrag = () => {
            dragging.active = false;
          };
          const cellClass = (index) => {
            const current = flatGrid.value[index] ?? "_";
            const letter = solutionLetters.value[index] ?? "";
            if (current === "#") return "bg-zinc-900 text-zinc-600 border border-zinc-800 hover:border-zinc-700";
            if (letter) return "bg-zinc-950 text-zinc-100 border border-zinc-700 hover:border-zinc-400";
            return "bg-zinc-950 text-zinc-300 border border-zinc-800 hover:border-zinc-500";
          };
          const cellLabel = (index) => {
            const current = flatGrid.value[index] ?? "_";
            if (current === "#") return "";
            const letter = solutionLetters.value[index];
            return letter ? letter.toUpperCase() : "";
          };
          const resizeGrid = (nextRows, nextCols) => {
            const next = createMatrix(nextRows, nextCols);
            for (let r = 0; r < Math.min(nextRows, grid.value.length); r += 1) {
              for (let c = 0; c < Math.min(nextCols, grid.value[0].length); c += 1) {
                next[r][c] = grid.value[r][c];
              }
            }
            grid.value = next;
            solutionLetters.value = [];
            solutionWords.value = [];
          };
          watch([rows, cols], ([nextRows, nextCols], [prevRows, prevCols]) => {
            if (nextRows !== prevRows || nextCols !== prevCols) {
              resizeGrid(nextRows, nextCols);
            }
          });
          const toggleLength = (length) => {
            const next = new Set(selectedLengths.value);
            if (next.has(length)) {
              next.delete(length);
            } else {
              next.add(length);
            }
            selectedLengths.value = next;
          };
          const resetGrid = () => {
            grid.value = createMatrix(rows.value, cols.value);
            solutionLetters.value = [];
            solutionWords.value = [];
            solveStatus.value = "";
            lastStatus.value = "";
          };
          const solve = async () => {
            if (disableSolve.value) return;
            solving.value = true;
            solveStatus.value = "Preparing model…";
            solutionLetters.value = [];
            solutionWords.value = [];
            lastStatus.value = "";
            try {
              const { content, metadata } = buildPuzzle(grid.value);
              if (!metadata.segments.length) {
                throw new Error("No viable word segments. Add more open cells.");
              }
              const requiredLengths = Array.from(new Set(metadata.segments.map((segment) => segment.length)));
              const activeWords = {};
              for (const length of requiredLengths) {
                if (!selectedLengths.value.has(length)) {
                  throw new Error(`Enable length ${length} to solve this grid.`);
                }
                const words = wordSource.value[length] ?? [];
                if (!words.length) {
                  throw new Error(`No words available for length ${length}.`);
                }
                activeWords[length] = words;
              }
              if (!activeWords[1]) {
                const singles = wordSource.value[1] ?? letters.split("");
                activeWords[1] = singles;
              }
              const wordData = buildWordData(activeWords);
              const model = new MiniZinc.Model();
              model.addFile("crosswords.mzn", crosswordsModel.value, false);
              model.addFile("all_words.dzn", wordData, false);
              model.addFile("main.mzn", content);
              const solveHandle = model.solve({ options: { solver: "gecode" } });
              solveStatus.value = "Running solver…";
              const result = await solveHandle;
              lastStatus.value = result.status ?? "UNKNOWN";
              if (!result.solution || !result.solution.output || !result.solution.output.json) {
                solveStatus.value = "Solver returned without a solution.";
                return;
              }
              const assignment = result.solution.output.json.L ?? [];
              const mapped = metadata.mapped.flat().map((cell) => {
                if (cell === 0) return "";
                const index = assignment[cell] ?? assignment[cell - 1];
                const letter = typeof index === "number" ? letters[index - 1] ?? "" : "";
                return letter;
              });
              solutionLetters.value = mapped;
              solveStatus.value = "Solved.";
              const words = metadata.segments.map((segment) => segment.map((id) => {
                const index = assignment[id] ?? assignment[id - 1];
                return typeof index === "number" ? letters[index - 1] ?? "" : "";
              }).join(""));
              solutionWords.value = words.filter((word) => word.length > 1);
            } catch (error) {
              solveStatus.value = error.message ?? String(error);
            } finally {
              solving.value = false;
            }
          };
          const loadWordList = async () => {
            const response = await fetch("./wordlist.txt");
            if (!response.ok) throw new Error("Failed to load word list.");
            const text = await response.text();
            const entries = text.split(/\r?\n/).map((word) => word.trim().toLowerCase()).filter(Boolean);
            const grouped = {};
            for (const word of entries) {
              const len = word.length;
              if (!grouped[len]) grouped[len] = new Set();
              grouped[len].add(word);
            }
            const map = Object.fromEntries(Object.entries(grouped).map(([length, set]) => [Number(length), Array.from(set).sort()]));
            return map;
          };
          const handlePointerUp = () => endDrag();

          onMounted(async () => {
            window.addEventListener("pointerup", handlePointerUp);
            try {
              const [wordMap, modelText] = await Promise.all([
                loadWordList(),
                fetch("./crosswords.mzn").then((res) => {
                  if (!res.ok) throw new Error("Missing crosswords.mzn");
                  return res.text();
                }),
              ]);
              await MiniZinc.init({
                workerURL: "https://cdn.jsdelivr.net/npm/minizinc/dist/minizinc-worker.js",
                wasmURL: "https://cdn.jsdelivr.net/npm/minizinc/dist/minizinc.wasm",
                dataURL: "https://cdn.jsdelivr.net/npm/minizinc/dist/minizinc.data",
              });
              wordSource.value = wordMap;
              availableLengths.value = Object.keys(wordMap).map((value) => Number(value)).sort((a, b) => a - b);
              selectedLengths.value = new Set(availableLengths.value);
              crosswordsModel.value = modelText;
              ready.value = true;
              solveStatus.value = "Runtime ready.";
            } catch (error) {
              loadError.value = error.message ?? String(error);
            }
          });

          onBeforeUnmount(() => window.removeEventListener("pointerup", handlePointerUp));
          return {
            rows,
            cols,
            grid,
            flatGrid,
            ready,
            loadError,
            solveStatus,
            solving,
            startDrag,
            dragCell,
            endDrag,
            cellClass,
            cellLabel,
            resetGrid,
            toggleLength,
            lengthOptions,
            activeWordCount,
            openCellCount,
            blockedCellCount,
            slotSummary,
            solve,
            disableSolve,
            solutionLetters,
            solutionWords,
            lastStatus,
          };
        },
      });
      app.mount("#app");
    </script>
  </body>
</html>
