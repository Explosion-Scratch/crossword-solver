<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Crossword Composer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            fontFamily: {
              mono: ["IBM Plex Mono", "ui-monospace", "SFMono-Regular", "Menlo", "Monaco", "Consolas", "Liberation Mono", "Courier New", "monospace"],
            },
          },
        },
      };
    </script>
  </head>
  <body class="min-h-screen bg-zinc-950 text-zinc-100 font-mono">
    <div id="app" class="mx-auto flex min-h-screen max-w-6xl flex-col gap-10 px-6 py-12">
      <header class="flex flex-col gap-4">
        <h1 class="text-3xl tracking-tight">Crossword Composer</h1>
        <p class="max-w-2xl text-sm text-zinc-400">Design a crossword grid, pick curated word banks, and solve it instantly in the browser with the MiniZinc WebAssembly runtime.</p>
      </header>
      <main class="flex flex-col gap-10">
        <section class="flex flex-col gap-6 rounded border border-zinc-800 bg-zinc-900/30 p-6 backdrop-blur">
          <div class="grid gap-6 md:grid-cols-2">
            <div class="flex flex-col gap-4">
              <div class="flex items-center justify-between gap-4">
                <label class="text-sm uppercase tracking-[0.2em] text-zinc-500">Grid Size</label>
                <div class="flex items-center gap-3 text-sm text-zinc-300">
                  <div class="flex items-center gap-2">
                    <span>Rows</span>
                    <input v-model.number="rows" type="number" min="3" max="18" class="w-16 bg-zinc-900 px-2 py-1 text-right text-sm text-zinc-100 outline-none ring-1 ring-inset ring-zinc-700 transition focus:ring-zinc-400" />
                  </div>
                  <div class="flex items-center gap-2">
                    <span>Cols</span>
                    <input v-model.number="cols" type="number" min="3" max="18" class="w-16 bg-zinc-900 px-2 py-1 text-right text-sm text-zinc-100 outline-none ring-1 ring-inset ring-zinc-700 transition focus:ring-zinc-400" />
                  </div>
                </div>
              </div>
              <button @click="resetGrid" class="w-full rounded border border-zinc-700 bg-zinc-950 px-3 py-2 text-sm uppercase tracking-[0.2em] text-zinc-200 transition hover:border-zinc-400 hover:text-white">Clear Grid</button>
              <div class="rounded border border-zinc-800 bg-zinc-950/70 p-3 text-xs text-zinc-400">
                <div class="flex justify-between">
                  <span>Active cells</span>
                  <span>{{ openCellCount }}</span>
                </div>
                <div class="flex justify-between">
                  <span>Black cells</span>
                  <span>{{ blockedCellCount }}</span>
                </div>
                <div class="flex justify-between">
                  <span>Word slots</span>
                  <span>{{ slotSummary.total }}</span>
                </div>
              </div>
            </div>
            <div class="flex flex-col gap-3">
              <label class="text-sm uppercase tracking-[0.2em] text-zinc-500">Word Lengths</label>
              <div class="flex flex-wrap gap-2">
                <button v-for="option in lengthOptions" :key="option.length" @click="toggleLength(option.length)" :class="[
                    'rounded border px-3 py-2 text-xs uppercase tracking-[0.2em] transition',
                    option && option.selected ? 'border-zinc-200 bg-zinc-100 text-zinc-900' : 'border-zinc-700 bg-zinc-950 text-zinc-200 hover:border-zinc-400',
                  ]">
                  {{ option?.label || '' }}
                </button>
              </div>
              <div class="rounded border border-zinc-800 bg-zinc-950/70 p-3 text-xs text-zinc-400">
                <div class="flex justify-between">
                  <span>Selected words</span>
                  <span>{{ activeWordCount }}</span>
                </div>
                <div class="flex flex-wrap gap-2 pt-3">
                  <span v-for="option in lengthOptions" :key="`length-chip-${option.length}`" class="rounded-full border border-zinc-800 px-2 py-1 text-[0.65rem] uppercase tracking-[0.25em] text-zinc-500" v-if="option && option.selected">
                    {{ option.length }}&nbsp;({{ option.count }})
                  </span>
                </div>
              </div>
            </div>
          </div>
          <div class="grid gap-6 md:grid-cols-[minmax(0,_2fr)_minmax(0,_1fr)]">
            <div class="rounded border border-zinc-800 bg-zinc-950/70 p-4">
          <div class="flex items-center justify-between">
            <div class="flex items-center gap-3">
              <h2 class="text-sm uppercase tracking-[0.2em] text-zinc-500">Layout</h2>
              <div class="flex items-center gap-2">
                <button
                  type="button"
                  @click="fillEntireGrid('blocked')"
                  class="h-6 w-6 rounded border border-zinc-700 bg-zinc-900 transition hover:border-zinc-400"
                  aria-label="Fill entire grid with blocks"
                  title="Fill entire grid with blocks"
                ></button>
                <button
                  type="button"
                  @click="fillEntireGrid('open')"
                  class="h-6 w-6 rounded border border-zinc-700 bg-zinc-950 transition hover:border-zinc-400"
                  aria-label="Clear all blocks"
                  title="Clear all blocks"
                ></button>
              </div>
            </div>
            <span class="text-xs text-zinc-500">Click or drag to toggle blocks</span>
          </div>
              <div
                class="mt-4 grid gap-px border border-zinc-800 bg-zinc-900/40 p-2"
                :style="{ gridTemplateColumns: `repeat(${cols}, minmax(0, 1fr))` }"
                @pointerleave="exitGrid"
              >
                <button
                  v-for="(cell, cellIndex) in flatGrid"
                  :key="cellIndex"
                  @pointerdown="onCellPointerDown(cellIndex)"
                  @pointerenter="onCellPointerEnter(cellIndex)"
                  @pointerleave="onCellPointerLeave(cellIndex)"
                  @pointerup="endDrag"
                  class="flex aspect-square items-center justify-center text-base font-semibold uppercase transition"
                  :class="cellClass(cellIndex)"
                >
                  <span class="select-none">{{ cellLabel(cellIndex) }}</span>
                </button>
              </div>
            </div>
            <div class="flex flex-col gap-4 rounded border border-zinc-800 bg-zinc-950/70 p-4">
              <h2 class="text-sm uppercase tracking-[0.2em] text-zinc-500">Solver</h2>
              <div class="space-y-2 text-sm text-zinc-300">
                <p v-if="!ready && !loadError">Preparing MiniZinc runtime…</p>
                <p v-if="loadError" class="text-red-400">{{ loadError }}</p>
                <p v-if="solveStatus">{{ solveStatus }}</p>
              </div>
              <button
                @click="solve"
                :disabled="disableSolve"
                class="w-full rounded border border-zinc-700 bg-zinc-950 px-3 py-2 text-sm uppercase tracking-[0.2em] transition disabled:cursor-not-allowed disabled:opacity-50 hover:border-zinc-300 hover:text-white"
              >
                {{ solving ? 'Solving…' : 'Solve Crossword' }}
              </button>
              <button
                v-if="solutionLetters.length"
                @click="clearSolve"
                class="w-full rounded border border-zinc-700 bg-zinc-950 px-3 py-2 text-sm uppercase tracking-[0.2em] transition hover:border-zinc-300 hover:text-white"
              >
                Clear Solve
              </button>
              <div v-if="solutionLetters.length" class="rounded border border-zinc-800 bg-zinc-900/40 p-3 text-xs text-zinc-300">
                <div class="flex justify-between">
                  <span>Status</span>
                  <span>{{ lastStatus }}</span>
                </div>
                <div class="flex justify-between">
                  <span>Filled slots</span>
                  <span>{{ solutionLetters.length }}</span>
                </div>
                <div class="flex flex-wrap gap-2 pt-3">
                  <span v-for="(entry, index) in solutionWords" :key="`solution-word-${index}`" class="rounded border border-zinc-800 px-2 py-1 text-[0.65rem] uppercase tracking-[0.25em] text-zinc-400">
                    {{ entry }}
                  </span>
                </div>
              </div>
            </div>
          </div>
        </section>
      </main>
    </div>
    <script type="module">
      import { createApp, ref, reactive, computed, watch, onMounted, onBeforeUnmount } from "https://unpkg.com/vue@3/dist/vue.esm-browser.js";
      import * as MiniZinc from "https://cdn.jsdelivr.net/npm/minizinc/dist/minizinc.mjs";

      const letters = "abcdefghijklmnopqrstuvwxyz";
      const createMatrix = (r, c) => Array.from({ length: r }, () => Array.from({ length: c }, () => "_"));
      const cloneMatrix = (matrix) => matrix.map((row) => row.slice());
      const buildProblemMatrix = (matrix) => {
        let id = 1;
        const mapped = matrix.map((row) => row.map((cell) => {
          if (cell === "#") return 0;
          const value = id;
          id += 1;
          return value;
        }));
        return { mapped, count: id - 1 };
      };
      const collectSegments = (grid, rows, cols) => {
        const segments = [];
        const extract = (sourceRows, sourceCols, mapper) => {
          for (let r = 0; r < sourceRows; r += 1) {
            const line = [];
            for (let c = 0; c < sourceCols; c += 1) {
              const value = mapper(r, c);
              if (value === 0) {
                if (line.length > 1) segments.push([...line]);
                line.length = 0;
              } else {
                line.push(value);
              }
            }
            if (line.length > 1) segments.push([...line]);
          }
        };
        extract(rows, cols, (r, c) => grid[r][c]);
        extract(cols, rows, (r, c) => grid[c][r]);
        return segments;
      };
      const gridPresentation = (matrix) => 
        matrix
            .map((row) => `%   ${row.map((cell) => (cell === "#" ? "#" : "_")).join(" ")}`).join("\n");
      const buildPuzzle = (matrix, prefills = []) => {
        const rows = matrix.length;
        const cols = matrix[0]?.length ?? 0;
        const { mapped, count } = buildProblemMatrix(matrix);
        const segments = collectSegments(mapped, rows, cols);
        const maxSegmentLength = segments.reduce((acc, segment) => Math.max(acc, segment.length), 1);
        const segmentLines = segments.map((segment) => {
          const padded = segment.concat(Array.from({ length: Math.max(maxSegmentLength - segment.length, 0) }, () => 0));
          return `${padded.join(", ")},`;
        });
        const problemLines = mapped.map((row) => `${row.join(", ")},`);
        const tables = segments.map((segment) => `table([${segment.map((value) => `L[${value}]`).join(", ")}], words${segment.length})`);
        const tableBlock = tables.length ? tables.join(" \n/\\ ") : "true";
        const assignments = [];
        if (Array.isArray(prefills) && prefills.length) {
          for (let index = 0; index < prefills.length; index += 1) {
            const letter = prefills[index];
            if (!letter) continue;
            const row = Math.floor(index / cols);
            const col = index % cols;
            const cellId = mapped[row]?.[col] ?? 0;
            if (!cellId) continue;
            const letterIndex = letters.indexOf(letter);
            if (letterIndex === -1) continue;
            assignments.push(`L[${cellId}] = ${letterIndex + 1}`);
          }
        }
        const constraintParts = [];
        if (tableBlock !== "true") constraintParts.push(tableBlock);
        if (assignments.length) constraintParts.push(...assignments);
        const constraintBlock = constraintParts.length ? constraintParts.join(" \n/\\ ") : "true";
        const content = [
          "%",
          "% Generated crossword",
          "%",
          `% (generated ${new Date().toISOString()} by browser grid)`,
          "%",
          "%",
          "% Problem to solve:",
          "%",
          gridPresentation(matrix),
          "",
          "include \"crosswords.mzn\";",
          "",
          "problem_name = \"crossword\";",
          "",
          `% number of letters to assign`,
          `N = ${count};`,
          "",
          "% distinct words",
          "require_distinct_words = 1;",
          "",
          "constraint",
          `  ${constraintBlock}`,
          ";",
          "",
          "% The segments (words)",
          "% (0 for fill outs)",
          `int: max_length = ${maxSegmentLength};`,
          `int: num_segments = ${segments.length};`,
          "array[1..num_segments, 1..max_length] of int: segments = array2d(1..num_segments, 1..max_length,",
          "[",
          segmentLines.join("\n"),
          "]);",
          "",
          "",
          "% Problem where each cell is assigned a unique index.",
          "% (0 means blocked cell)",
          `int: rows = ${rows};`,
          `int: cols = ${cols};`,
          "array[1..rows, 1..cols] of int: problem = array2d(1..rows, 1..cols,",
          "[",
          problemLines.join("\n"),
          "]);",
          "",
        ].join("\n");
        return { content, metadata: { mapped, segments, rows, cols } };
      };
      const buildWordData = (entriesByLength) => {
        const lengths = Object.keys(entriesByLength)
          .map((value) => Number(value))
          .sort((a, b) => a - b);
        const blocks = lengths
          .filter((length) => entriesByLength[length]?.length)
          .map((length) => {
            const entries = entriesByLength[length];
            const rows = entries
              .map(({ word }) => word.split("").map((letter) => letters.indexOf(letter) + 1))
              .map((codes) => `${codes.join(", ")},`).join("\n");
            return [
              `int: num_words${length} = ${entries.length};`,
              `array[1..num_words${length}, 1..${length}] of int: words${length} = array2d(1..num_words${length}, 1..${length},`,
              "[",
              rows,
              "]);",
              "",
            ].join("\n");
          });
        return blocks.join("\n");
      };
      const deriveSlots = (matrix) => {
        const rows = matrix.length;
        const cols = matrix[0]?.length ?? 0;
        const { mapped } = buildProblemMatrix(matrix);
        const segments = collectSegments(mapped, rows, cols);
        const summary = segments.reduce((acc, segment) => {
          const len = segment.length;
          acc[len] = (acc[len] ?? 0) + 1;
          acc.total += 1;
          return acc;
        }, { total: 0 });
        return summary;
      };
      const app = createApp({
        setup() {
          const rows = ref(8);
          const cols = ref(8);
          const grid = ref(createMatrix(rows.value, cols.value));
          const dragging = reactive({ active: false, next: "#", startIndex: -1 });
          const ready = ref(false);
          const loadError = ref("");
          const solving = ref(false);
          const solveStatus = ref("");
          const lastStatus = ref("");
          const solutionLetters = ref([]);
          const solutionWords = ref([]);
          const solvedCells = ref(new Set());
          const userPrefills = ref(new Map());
          const wordSource = ref([]);
          const availableLengths = ref([]);
          const selectedLengths = ref(new Set());
          const crosswordsModel = ref("");
          const hoveredCell = ref(-1);
          const hoveredWordIndex = ref(-1);
          const slotSummary = computed(() => deriveSlots(grid.value || createMatrix(rows.value, cols.value)));
          const flatGrid = computed(() => (grid.value || []).flat());
          const openCellCount = computed(() => flatGrid.value.filter((cell) => cell !== "#").length);
          const blockedCellCount = computed(() => flatGrid.value.filter((cell) => cell === "#").length);
          const lengthOptions = computed(() =>
            (availableLengths.value ?? []).map((length) => ({
              length,
              selected: selectedLengths.value.has(length),
              count: wordSource.value.filter((entry) => entry.word.length === length).length,
              label: `${length}L`,
            }))
          );
          const activeWordCount = computed(() => Array.from(selectedLengths.value || []).reduce((acc, length) => acc + wordSource.value.filter((entry) => entry.word.length === length).length, 0));
          const disableSolve = computed(() => !ready.value || solving.value || loadError.value.length > 0 || !slotSummary.value.total);
          const applyCell = (index, value) => {
            const next = cloneMatrix(grid.value);
            const r = Math.floor(index / cols.value);
            const c = index % cols.value;
            if (!next[r]) return;
            next[r][c] = value;
            grid.value = next;
            solutionLetters.value = [];
            solutionWords.value = [];
            solvedCells.value = new Set();
          };
          const startDrag = (index) => {
            const current = flatGrid.value[index] ?? "_";
            const next = current === "#" ? "_" : "#";
            dragging.active = true;
            dragging.next = next;
            dragging.startIndex = index;
            applyCell(index, next);
            userPrefills.value.delete(index);
          };
          const dragCell = (index) => {
            if (!dragging.active) return;
            applyCell(index, dragging.next);
            userPrefills.value.delete(index);
          };
          const endDrag = () => {
            dragging.active = false;
            dragging.startIndex = -1;
          };
          const cellClass = (index) => {
            const current = flatGrid.value[index] ?? "_";
            const prefilled = userPrefills.value.has(index);
            const solved = solvedCells.value.has(index);
            const hovered = hoveredCell.value === index || hoveredSegmentCells.value.has(index);
            const letter = solutionLetters.value[index] ?? "";
            if (current === "#") return "bg-zinc-900 text-zinc-600 border border-zinc-800 hover:border-zinc-700";
            if (prefilled) return hovered ? "bg-zinc-950 text-white border border-zinc-400" : "bg-zinc-950 text-zinc-100 border border-zinc-600 hover:border-zinc-400";
            if (solved && letter) return hovered ? "bg-green-900/30 text-zinc-100 border border-green-400" : "bg-green-900/20 text-zinc-100 border border-green-600/40 hover:border-green-400";
            if (hovered) return "bg-zinc-950 text-zinc-100 border border-zinc-400";
            if (letter) return "bg-zinc-950 text-zinc-100 border border-zinc-700 hover:border-zinc-400";
            return "bg-zinc-950 text-zinc-300 border border-zinc-800 hover:border-zinc-500";
          };
          const cellLabel = (index) => {
            const current = flatGrid.value[index] ?? "_";
            if (current === "#") return "";
            if (userPrefills.value.has(index)) return userPrefills.value.get(index).toUpperCase();
            const letter = solutionLetters.value[index];
            return letter ? letter.toUpperCase() : "";
          };
          const enterCell = (index) => {
            hoveredCell.value = index;
          };
          const leaveCell = (index) => {
            if (hoveredCell.value === index) hoveredCell.value = -1;
          };
          const resizeGrid = (nextRows, nextCols) => {
            const next = createMatrix(nextRows, nextCols);
            for (let r = 0; r < Math.min(nextRows, grid.value.length); r += 1) {
              for (let c = 0; c < Math.min(nextCols, grid.value[0].length); c += 1) {
                next[r][c] = grid.value[r][c];
              }
            }
            grid.value = next;
            solutionLetters.value = [];
            solutionWords.value = [];
            userPrefills.value.clear();
            solvedCells.value = new Set();
          };
          watch([rows, cols], ([nextRows, nextCols], [prevRows, prevCols]) => {
            if (nextRows !== prevRows || nextCols !== prevCols) {
              resizeGrid(nextRows, nextCols);
            }
          });
          const toggleLength = (length) => {
            const next = new Set(selectedLengths.value);
            if (next.has(length)) {
              next.delete(length);
            } else {
              next.add(length);
            }
            selectedLengths.value = next;
          };
          const resetGrid = () => {
            grid.value = createMatrix(rows.value, cols.value);
            solutionLetters.value = [];
            solutionWords.value = [];
            userPrefills.value.clear();
            solvedCells.value = new Set();
            solveStatus.value = "";
            lastStatus.value = "";
          };
          const fillEntireGrid = (mode) => {
            const next = createMatrix(rows.value, cols.value);
            for (let r = 0; r < rows.value; r += 1) {
              for (let c = 0; c < cols.value; c += 1) {
                next[r][c] = mode === "blocked" ? "#" : "_";
              }
            }
            grid.value = next;
            userPrefills.value.clear();
            solutionLetters.value = [];
            solutionWords.value = [];
            solvedCells.value = new Set();
            solveStatus.value = "";
            lastStatus.value = "";
          };
          const clearSolve = () => {
            solutionLetters.value = [];
            solutionWords.value = [];
            solvedCells.value = new Set();
            solveStatus.value = "";
            lastStatus.value = "";
          };
          const applyPrefill = (index, letter) => {
            const current = flatGrid.value[index] ?? "#";
            if (current === "#") return;
            if (letter) {
              userPrefills.value.set(index, letter);
            } else {
              userPrefills.value.delete(index);
            }
          };
          const handleKey = (event) => {
            if (hoveredCell.value < 0) return;
            const key = event.key.toLowerCase();
            if (key.length === 1 && letters.includes(key)) {
              applyPrefill(hoveredCell.value, key);
              solutionLetters.value = [];
              solutionWords.value = [];
              solvedCells.value = new Set();
            }
            if (event.key === "Backspace" || event.key === "Delete") {
              applyPrefill(hoveredCell.value, "");
              solutionLetters.value = [];
              solutionWords.value = [];
              solvedCells.value = new Set();
            }
          };
          const wordList = computed(() => wordSource.value.filter((entry) => selectedLengths.value.has(entry.word.length)));
          const segmentDetails = computed(() => {
            const activeGrid = grid.value;
            if (!activeGrid.length) return [];
            const { mapped } = buildProblemMatrix(activeGrid);
            const segments = collectSegments(mapped, rows.value, cols.value);
            const idToIndex = new Map();
            mapped.forEach((row, rowIndex) => {
              row.forEach((cellId, colIndex) => {
                if (!cellId) return;
                idToIndex.set(cellId, rowIndex * cols.value + colIndex);
              });
            });
            return segments.map((segment, segmentIndex) => {
              const flatIndices = segment.map((id) => idToIndex.get(id)).filter((value) => typeof value === "number");
              const lettersInSegment = flatIndices.map((flatIndex) => {
                if (userPrefills.value.has(flatIndex)) return userPrefills.value.get(flatIndex);
                return solutionLetters.value[flatIndex] ?? "";
              });
              const length = segment.length;
              const candidates = wordSource.value.filter((entry) => {
                if (entry.word.length !== length) return false;
                for (let i = 0; i < length; i += 1) {
                  const char = lettersInSegment[i];
                  if (char && entry.word[i] !== char) return false;
                }
                return true;
              });
              const joined = lettersInSegment.join("");
              const exact = candidates.find((entry) => entry.word === joined);
              const chosen = exact ?? candidates[0];
              const clue = chosen?.clues?.[0] ?? "";
              const isFilled = lettersInSegment.length === length && lettersInSegment.every((char) => char && char.length === 1);
              return {
                index: segmentIndex,
                flatIndices,
                letters: lettersInSegment,
                length,
                word: joined,
                entry: chosen,
                clue,
                isFilled,
              };
            });
          });
          const hoveredSegmentCells = computed(() => {
            if (hoveredWordIndex.value < 0) return new Set();
            const target = segmentDetails.value[hoveredWordIndex.value];
            if (!target) return new Set();
            return new Set(target.flatIndices);
          });
          const solvedSegments = computed(() => segmentDetails.value.filter((segment) => segment.isFilled && segment.flatIndices.length));
          const exitGrid = () => {
            hoveredCell.value = -1;
          };
          const onCellPointerDown = (index) => {
            startDrag(index);
            enterCell(index);
          };
          const onCellPointerEnter = (index) => {
            if (dragging.active) {
              dragCell(index);
            }
            enterCell(index);
          };
          const onCellPointerLeave = (index) => {
            leaveCell(index);
          };
          const solve = async () => {
            if (disableSolve.value) return;
            solving.value = true;
            solveStatus.value = "Preparing model…";
            solutionLetters.value = [];
            solutionWords.value = [];
            lastStatus.value = "";
            try {
              const prefillArray = Array.from({ length: rows.value * cols.value }, (_, index) => userPrefills.value.get(index) ?? "");
              const { content, metadata } = buildPuzzle(grid.value, prefillArray);
              if (!metadata.segments.length) {
                throw new Error("No viable word segments. Add more open cells.");
              }
              const requiredLengths = Array.from(new Set(metadata.segments.map((segment) => segment.length)));
              const activeWords = {};
              for (const length of requiredLengths) {
                if (!selectedLengths.value.has(length)) {
                  throw new Error(`Enable length ${length} to solve this grid.`);
                }
                const entries = wordSource.value.filter((entry) => entry.word.length === length);
                if (!entries.length) {
                  throw new Error(`No words available for length ${length}.`);
                }
                activeWords[length] = entries;
              }
              if (!activeWords[1]) {
                const singles = letters.split("").map((letter) => ({ word: letter, clues: [] }));
                activeWords[1] = singles;
              }
              const wordData = buildWordData(activeWords);
              const model = new MiniZinc.Model();
              model.addFile("crosswords.mzn", crosswordsModel.value, false);
              model.addFile("all_words.dzn", wordData, false);
              model.addFile("main.mzn", content);
              const solveHandle = model.solve({ options: { solver: "gecode" } });
              solveStatus.value = "Running solver…";
              const result = await solveHandle;
              lastStatus.value = result.status ?? "UNKNOWN";
              if (!result.solution || !result.solution.output || !result.solution.output.json) {
                solveStatus.value = "Solver returned without a solution.";
                return;
              }
              const assignment = result.solution.output.json.L ?? [];
              const mapped = metadata.mapped.flat().map((cell, flatIndex) => {
                if (cell === 0) return "";
                const assigned = assignment[cell] ?? assignment[cell - 1];
                const letter = typeof assigned === "number" ? letters[assigned - 1] ?? "" : "";
                if (userPrefills.value.has(flatIndex)) return userPrefills.value.get(flatIndex);
                return letter;
              });
              solutionLetters.value = mapped;
              solveStatus.value = "Solved.";
              const solvedSet = new Set();
              metadata.mapped.forEach((row, rowIndex) => {
                row.forEach((cellId, colIndex) => {
                  if (!cellId) return;
                  const flatIndex = rowIndex * metadata.cols + colIndex;
                  if (userPrefills.value.has(flatIndex)) return;
                  const value = assignment[cellId] ?? assignment[cellId - 1];
                  if (typeof value === "number" && letters[value - 1]) {
                    solvedSet.add(flatIndex);
                  }
                });
              });
              solvedCells.value = solvedSet;
              const words = metadata.segments.map((segment) => segment.map((id) => {
                const index = assignment[id] ?? assignment[id - 1];
                return typeof index === "number" ? letters[index - 1] ?? "" : "";
              }).join(""));
              solutionWords.value = words.filter((word) => word.length > 1);
            } catch (error) {
              solveStatus.value = error.message ?? String(error);
            } finally {
              solving.value = false;
            }
          };
          const loadWordList = async () => {
            const response = await fetch("./words.json");
            if (!response.ok) throw new Error("Failed to load word list.");
            const data = await response.json();
            return data.map(([word, clues]) => ({ word, clues }));
          };
          const handlePointerUp = () => endDrag();

          onMounted(async () => {
            window.addEventListener("pointerup", handlePointerUp);
            window.addEventListener("keydown", handleKey);
            try {
              const [wordEntries, modelText] = await Promise.all([
                loadWordList(),
                fetch("./crosswords.mzn").then((res) => {
                  if (!res.ok) throw new Error("Missing crosswords.mzn");
                  return res.text();
                }),
              ]);
              await MiniZinc.init({
                workerURL: "https://cdn.jsdelivr.net/npm/minizinc/dist/minizinc-worker.js",
                wasmURL: "https://cdn.jsdelivr.net/npm/minizinc/dist/minizinc.wasm",
                dataURL: "https://cdn.jsdelivr.net/npm/minizinc/dist/minizinc.data",
              });
              wordSource.value = wordEntries;
              availableLengths.value = Array.from(new Set(wordEntries.map((entry) => entry.word.length))).sort((a, b) => a - b);
              selectedLengths.value = new Set(availableLengths.value);
              crosswordsModel.value = modelText;
              ready.value = true;
              solveStatus.value = "Runtime ready.";
            } catch (error) {
              loadError.value = error.message ?? String(error);
            }
          });

          onBeforeUnmount(() => {
            window.removeEventListener("pointerup", handlePointerUp);
            window.removeEventListener("keydown", handleKey);
          });
          return {
            rows,
            cols,
            grid,
            flatGrid,
            ready,
            loadError,
            solveStatus,
            solving,
            startDrag,
            dragCell,
            endDrag,
            cellClass,
            cellLabel,
            resetGrid,
            toggleLength,
            lengthOptions,
            activeWordCount,
            openCellCount,
            blockedCellCount,
            slotSummary,
            solve,
            disableSolve,
            solutionLetters,
            solutionWords,
            lastStatus,
            fillEntireGrid,
            clearSolve,
            wordList,
            exitGrid,
            onCellPointerDown,
            onCellPointerEnter,
            onCellPointerLeave,
          };
        },
      });
      app.mount("#app");
    </script>
  </body>
</html>
